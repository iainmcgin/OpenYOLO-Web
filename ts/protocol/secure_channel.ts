/*
 * Copyright 2017 The OpenYOLO for Web Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import {createMessageListener, FilteringEventListener, isPermittedOrigin, RpcMessageListener, WindowLike} from './comms';
import {OpenYoloError, OpenYoloInternalError} from './errors';
import {ackMessage, channelConnectMessage, channelReadyMessage, PostMessageType, readyForConnectMessage} from './post_messages';
import {RpcMessage, RpcMessageData, RpcMessageType} from './rpc_messages';
import {PromiseResolver, sha256, timeoutPromise} from './utils';

/**
 * The timeout for ack message.
 */
const ACK_TIMEOUT_MS = 500;

export type UnknownMessageEventListener = (ev: MessageEvent) => void;

interface ListenerPair {
  portListener: FilteringEventListener;
  wrappedListener: RpcMessageListener<any>;
}

export class SecureChannel {
  private mainListener: (ev: MessageEvent) => void;
  private listeners: Array<ListenerPair|null> = [];
  private fallbackListeners: UnknownMessageEventListener[] = [];

  static async clientConnect(
      clientWindow: WindowLike,
      providerWindow: WindowLike,
      connectionNonce: string,
      connectionNonceHash: string): Promise<SecureChannel> {
    // await the provider notifying us that it is ready to connect
    await SecureChannel.providerReadyToConnect(
        clientWindow, connectionNonceHash);

    const channel = new MessageChannel();

    const readyPromiseResolver = new PromiseResolver();
    // register another listener for the success / fail of establishing the
    // connection.

    const readyListener =
        createMessageListener(PostMessageType.channelReady, () => {
          readyPromiseResolver.resolve();
        });

    const errorListener =
        createMessageListener(PostMessageType.channelError, (data) => {
          readyPromiseResolver.reject(OpenYoloError.fromData(data));
        });

    clientWindow.addEventListener('message', readyListener);
    clientWindow.addEventListener('message', errorListener);

    // send the connection initialization message, carrying the port for
    // subsequent communication.
    providerWindow.postMessage(
        channelConnectMessage(connectionNonce), '*', [channel.port2]);

    try {
      // await ready, and if successful, remove our temporary ready listener
      // and return the established channel.
      await readyPromiseResolver.promise;
      return new SecureChannel(channel.port1);
    } catch (err) {
      // failed to establish the connection. Close the now defunct port
      channel.port1.close();
      throw err;
    } finally {
      clientWindow.removeEventListener('message', readyListener);
      clientWindow.removeEventListener('message', errorListener);
    }
  }

  static providerReadyToConnect(
      clientWindow: WindowLike,
      expectedNonceHash: string): Promise<void> {
    let promiseResolver = new PromiseResolver<void>();
    let listener =
        createMessageListener(PostMessageType.readyForConnect, (nonce) => {
          if (expectedNonceHash === nonce) {
            promiseResolver.resolve();
          }
        });

    // add the ready listener, then remove it when done
    clientWindow.addEventListener('message', listener);
    promiseResolver.promise.then(
        () => {
          clientWindow.removeEventListener('message', listener);
        },
        () => {
          clientWindow.removeEventListener('message', listener);
        });

    return promiseResolver.promise;
  }

  /**
   * Connect method that the OpenYOLO provider calls to establish contact
   * with the client.
   */
  static async providerConnect(
      providerWindow: WindowLike,
      permittedOrigins: string[],
      connectionNonce: string): Promise<SecureChannel> {
    let port: MessagePort|null = null;
    let promiseResolver = new PromiseResolver<SecureChannel>();

    let listener = createMessageListener(
        PostMessageType.channelConnect,
        async function(nonce: string, type, ev) {
          // Runtime check as nonce could be anything.
          if (typeof nonce !== 'string') {
            return;
          }
          // The connection nonce (ID) in the URL is the hash of a nonce
          // generated by the client. The client sends the actual nonce as a
          // challenge, so this computes the hash of the nonce received to make
          // sure it corresponds to the hash.
          // Ignored otherwise, may be anything.
          const nonceHash = await sha256(nonce);
          if (nonceHash !== connectionNonce) {
            return;
          }

          if (!isPermittedOrigin(ev.origin, permittedOrigins)) {
            // Invalid origin indicates a potential attack.
            promiseResolver.reject(
                OpenYoloInternalError.untrustedOrigin(ev.origin));
            return;
          }

          if (!ev.ports) {
            promiseResolver.reject(OpenYoloInternalError.illegalStateError(
                'channel initialization message does not contain ports'));
            return;
          }

          port = ev.ports[0] as MessagePort;
          providerWindow.parent.postMessage(
              channelReadyMessage(connectionNonce), ev.origin);
          promiseResolver.resolve(new SecureChannel(port));
        });

    // listen for the initialization message, and unlisten once the connection
    // succeeds or fails
    providerWindow.addEventListener('message', listener);
    promiseResolver.promise.then(
        () => {
          providerWindow.removeEventListener('message', listener);
        },
        (err) => {
          providerWindow.removeEventListener('message', listener);
        });

    // send the 'ready to connect' message to the client.
    providerWindow.parent.postMessage(
        readyForConnectMessage(connectionNonce), '*');

    return promiseResolver.promise;
  }

  constructor(private port: MessagePort) {
    this.mainListener = (ev) => {
      let anyMatched = false;
      for (let i = 0; i < this.listeners.length; i++) {
        let listener = this.listeners[i];
        if (!listener) continue;
        anyMatched = !!listener.portListener(ev) || anyMatched;
      }

      if (anyMatched) {
        return;
      }

      for (let i = 0; i < this.fallbackListeners.length; i++) {
        this.fallbackListeners[i](ev);
      }
    };

    this.port.addEventListener('message', this.mainListener);
    this.port.start();
  }

  send<T extends RpcMessageType>(message: RpcMessage<T>): void {
    this.port.postMessage(message);
  }

  /**
   * Sends a message and waits for acknowledgment of the recipient.
   */
  sendAndWaitAck<T extends RpcMessageType>(message: RpcMessage<T>):
      Promise<void> {
    const promiseResolver = new PromiseResolver<void>();
    message.data.ack = true;
    const ackListner = createMessageListener(PostMessageType.ack, (id) => {
      if (id === message.data.id) {
        this.port.removeEventListener('message', ackListner);
        promiseResolver.resolve();
      }
    });
    const timeout = timeoutPromise<SecureChannel>(
        OpenYoloInternalError.ackTimeout(), ACK_TIMEOUT_MS);
    timeout.catch((err) => {
      this.port.removeEventListener('message', ackListner);
    });
    this.port.addEventListener('message', ackListner);
    this.send(message);
    // Cast is safe as the timeout promise never resolves.
    return Promise.race([timeout, promiseResolver.promise]) as Promise<void>;
  }

  listen<T extends RpcMessageType>(
      messageType: T,
      listener: RpcMessageListener<T>): number {
    if (!messageType || !listener) {
      throw OpenYoloInternalError.illegalStateError('invalid type or listener');
    }

    let portListener = createMessageListener(
        messageType,
        (data: RpcMessageData<T>, type: T, event: MessageEvent) => {
          // If acknowledgement is required, send the message to the sender.
          // TODO: a TS compiler bug appears to be causing intermittent problems
          // with resolving RpcMessageDataTypes[T]. Cast to any until this
          // is resolved
          const anyData = data as any;
          if (anyData.ack) {
            this.port.postMessage(ackMessage(anyData.id));
          }
          listener(data, type, event);
        });
    let listenerPair = {portListener, wrappedListener: listener};
    this.listeners.push(listenerPair);
    return this.listeners.length - 1;
  }

  addFallbackListener(fallbackListener: UnknownMessageEventListener) {
    this.fallbackListeners.push(fallbackListener);
  }

  unlisten(key: number): RpcMessageListener<any>|null {
    let listenerPair = this.listeners[key];
    if (!listenerPair) {
      return null;
    }

    this.listeners[key] = null;
    return listenerPair.wrappedListener;
  }

  dispose(): void {
    this.port.removeEventListener('message', this.mainListener);
    this.listeners = [];
    this.fallbackListeners = [];
    this.port.close();
  }
}
